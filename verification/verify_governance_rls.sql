BEGIN;

DO $$
DECLARE
    v_user_a_id UUID := '00000000-0000-0000-0000-00000000000A';
    v_user_b_id UUID := '00000000-0000-0000-0000-00000000000B';
    v_entity_b_id UUID;
    v_asset_b_id UUID;
    v_task_b_id UUID;
    v_count INTEGER;
BEGIN
    RAISE NOTICE 'Starting Governance RLS Verification...';

    -- 1. Setup Data for User B
    INSERT INTO auth.users (id, email) VALUES (v_user_a_id, 'user_a@test.com')
    ON CONFLICT (id) DO NOTHING;
    INSERT INTO public.profiles (id, email) VALUES (v_user_a_id, 'user_a@test.com')
    ON CONFLICT (id) DO NOTHING;

    INSERT INTO auth.users (id, email) VALUES (v_user_b_id, 'user_b@test.com')
    ON CONFLICT (id) DO NOTHING;
    INSERT INTO public.profiles (id, email) VALUES (v_user_b_id, 'user_b@test.com')
    ON CONFLICT (id) DO NOTHING;

    -- Create Entity for User B (User B will own the asset)
    INSERT INTO public.entities (name, type)
    VALUES ('Entity User B', 'FAMILY')
    RETURNING id INTO v_entity_b_id;

    -- Create Asset for User B (Owner is User B)
    INSERT INTO public.assets (name, entity_id, type, currency, owner_id)
    VALUES ('Asset User B', v_entity_b_id, 'BANK', 'USD', v_user_b_id)
    RETURNING id INTO v_asset_b_id;

    -- Grant access to User B explicitly (Owner already has implicit access usually, but let's be safe if system relies on access_grants)
    -- The memory says "The `governance_tasks` table ... RLS policies allow ... for users with ANY access_grant".
    -- "The `public.assets` table includes an `owner_id`...".
    -- RLS policy:
    -- EXISTS (SELECT 1 FROM public.access_grants ag WHERE ag.asset_id = governance_tasks.asset_id AND ag.user_id = auth.uid())
    -- So User B needs an access grant.
    -- Usually owner gets an access grant automatically via trigger? Or needs to be inserted?
    -- Memory says "The `verification/verify_governance_tasks.sql` script ... explicitly checking for the existence of `access_grants` (automatically generated by the `on_asset_created` trigger)".
    -- So User B should have an access grant.

    -- Create Task for User B's asset
    INSERT INTO public.governance_tasks (asset_id, title, priority, status)
    VALUES (v_asset_b_id, 'Task for User B', 'HIGH', 'OPEN')
    RETURNING id INTO v_task_b_id;

    RAISE NOTICE 'Task Created: %', v_task_b_id;

    -- 2. Test as User A (Should NOT see the task)
    -- Switch to User A context
    PERFORM set_config('request.jwt.claim.sub', v_user_a_id::text, true);
    PERFORM set_config('role', 'authenticated', true);

    SELECT COUNT(*) INTO v_count
    FROM public.governance_tasks
    WHERE id = v_task_b_id;

    IF v_count != 0 THEN
        RAISE EXCEPTION 'RLS Failure: User A can see User B task. Count: %', v_count;
    END IF;
    RAISE NOTICE 'Assertion Passed: User A cannot see User B task.';

    -- 3. Test as User B (Should see the task)
    -- Switch to User B context
    PERFORM set_config('request.jwt.claim.sub', v_user_b_id::text, true);
    PERFORM set_config('role', 'authenticated', true);

    -- Ensure User B has access grant (trigger might have created it, but let's verify/create if needed for test robustness in DO block transaction)
    -- Trigger on asset creation usually runs as creator. Here we created asset as superuser/postgres in DO block.
    -- So trigger might have failed or created grant for superuser?
    -- Let's manually insert access grant for User B to be sure.
    INSERT INTO public.access_grants (asset_id, user_id, permission_level)
    VALUES (v_asset_b_id, v_user_b_id, 'OWNER')
    ON CONFLICT DO NOTHING;

    SELECT COUNT(*) INTO v_count
    FROM public.governance_tasks
    WHERE id = v_task_b_id;

    IF v_count != 1 THEN
        RAISE EXCEPTION 'RLS Failure: User B cannot see their own task. Count: %', v_count;
    END IF;
    RAISE NOTICE 'Assertion Passed: User B can see their own task.';

    RAISE NOTICE 'All RLS Tests Passed Successfully!';
END $$;

ROLLBACK;
